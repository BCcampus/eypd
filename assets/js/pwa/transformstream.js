function TransformStreamCloseReadable(a){if(!0===a._errored)throw new TypeError('TransformStream is already errored');if(!0===a._readableClosed)throw new TypeError('Readable side is already closed');TransformStreamCloseReadableInternal(a)}function TransformStreamEnqueueToReadable(a,b){if(!0===a._errored)throw new TypeError('TransformStream is already errored');if(!0===a._readableClosed)throw new TypeError('Readable side is already closed');const c=a._readableController;try{ReadableStreamDefaultControllerEnqueue(c,b)}catch(b){throw a._readableClosed=!0,TransformStreamErrorIfNeeded(a,b),a._storedError}const d=ReadableStreamDefaultControllerGetDesiredSize(c);!0==0>=d&&!1===a._backpressure&&TransformStreamSetBackpressure(a,!0)}function TransformStreamError(a,b){if(!0===a._errored)throw new TypeError('TransformStream is already errored');TransformStreamErrorInternal(a,b)}function TransformStreamCloseReadableInternal(a){assert(!1===a._errored),assert(!1===a._readableClosed);try{ReadableStreamDefaultControllerClose(a._readableController)}catch(a){assert(!1)}a._readableClosed=!0}function TransformStreamErrorIfNeeded(a,b){!1===a._errored&&TransformStreamErrorInternal(a,b)}function TransformStreamErrorInternal(a,b){assert(!1===a._errored),a._errored=!0,a._storedError=b,!1===a._writableDone&&WritableStreamDefaultControllerError(a._writableController,b),!1===a._readableClosed&&ReadableStreamDefaultControllerError(a._readableController,b)}function TransformStreamReadableReadyPromise(a){return(assert(void 0!==a._backpressureChangePromise,'_backpressureChangePromise should have been initialized'),!1===a._backpressure)?Promise.resolve():(assert(!0===a._backpressure,'_backpressure should have been initialized'),a._backpressureChangePromise)}function TransformStreamSetBackpressure(a,b){assert(a._backpressure!==b,'TransformStreamSetBackpressure() should be called only when backpressure is changed'),a._backpressureChangePromise!==void 0&&a._backpressureChangePromise_resolve(b),a._backpressureChangePromise=new Promise((b)=>{a._backpressureChangePromise_resolve=b}),a._backpressureChangePromise.then((a)=>{assert(a!==b,'_backpressureChangePromise should be fulfilled only when backpressure is changed')}),a._backpressure=b}function TransformStreamDefaultTransform(a,b){const c=b._controlledTransformStream;return TransformStreamEnqueueToReadable(c,a),Promise.resolve()}function TransformStreamTransform(a,b){assert(!1===a._errored),assert(!1===a._transforming),assert(!1===a._backpressure),a._transforming=!0;const c=a._transformer,d=a._transformStreamController,e=PromiseInvokeOrPerformFallback(c,'transform',[b,d],TransformStreamDefaultTransform,[b,d]);return e.then(()=>{return a._transforming=!1,TransformStreamReadableReadyPromise(a)},(b)=>{return TransformStreamErrorIfNeeded(a,b),Promise.reject(b)})}function IsTransformStreamDefaultController(a){return!!typeIsObject(a)&&!!Object.prototype.hasOwnProperty.call(a,'_controlledTransformStream')}function IsTransformStream(a){return!!typeIsObject(a)&&!!Object.prototype.hasOwnProperty.call(a,'_transformStreamController')}class TransformStreamSink{constructor(a,b){this._transformStream=a,this._startPromise=b}start(a){const b=this._transformStream;return b._writableController=a,this._startPromise.then(()=>TransformStreamReadableReadyPromise(b))}write(a){const b=this._transformStream;return TransformStreamTransform(b,a)}abort(){const a=this._transformStream;a._writableDone=!0,TransformStreamErrorInternal(a,new TypeError('Writable side aborted'))}close(){const a=this._transformStream;assert(!1===a._transforming),a._writableDone=!0;const b=PromiseInvokeOrNoop(a._transformer,'flush',[a._transformStreamController]);return b.then(()=>{return!0===a._errored?Promise.reject(a._storedError):(!1===a._readableClosed&&TransformStreamCloseReadableInternal(a),Promise.resolve())}).catch((b)=>{return TransformStreamErrorIfNeeded(a,b),Promise.reject(a._storedError)})}}class TransformStreamSource{constructor(a,b){this._transformStream=a,this._startPromise=b}start(a){const b=this._transformStream;return b._readableController=a,this._startPromise.then(()=>{return(assert(void 0!==b._backpressureChangePromise,'_backpressureChangePromise should have been initialized'),!0===b._backpressure)?Promise.resolve():(assert(!1===b._backpressure,'_backpressure should have been initialized'),b._backpressureChangePromise)})}pull(){const a=this._transformStream;return assert(!0===a._backpressure,'pull() should be never called while _backpressure is false'),assert(void 0!==a._backpressureChangePromise,'_backpressureChangePromise should have been initialized'),TransformStreamSetBackpressure(a,!1),a._backpressureChangePromise}cancel(){const a=this._transformStream;a._readableClosed=!0,TransformStreamErrorInternal(a,new TypeError('Readable side canceled'))}}class TransformStreamDefaultController{constructor(a){if(!1===IsTransformStream(a))throw new TypeError('TransformStreamDefaultController can only be constructed with a TransformStream instance');if(void 0!==a._transformStreamController)throw new TypeError('TransformStreamDefaultController instances can only be created by the TransformStream constructor');this._controlledTransformStream=a}get desiredSize(){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException('desiredSize');const a=this._controlledTransformStream,b=a._readableController;return ReadableStreamDefaultControllerGetDesiredSize(b)}enqueue(a){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException('enqueue');TransformStreamEnqueueToReadable(this._controlledTransformStream,a)}close(){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException('close');TransformStreamCloseReadable(this._controlledTransformStream)}error(a){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException('error');TransformStreamError(this._controlledTransformStream,a)}}class TransformStream{constructor(a={}){this._transformer=a;const{readableStrategy:b,writableStrategy:c}=a;this._transforming=!1,this._errored=!1,this._storedError=void 0,this._writableController=void 0,this._readableController=void 0,this._transformStreamController=void 0,this._writableDone=!1,this._readableClosed=!1,this._backpressure=void 0,this._backpressureChangePromise=void 0,this._backpressureChangePromise_resolve=void 0,this._transformStreamController=new TransformStreamDefaultController(this);let d;const e=new Promise((a)=>{d=a}),f=new TransformStreamSource(this,e);this._readable=new ReadableStream(f,b);const g=new TransformStreamSink(this,e);this._writable=new WritableStream(g,c),assert(this._writableController!==void 0),assert(this._readableController!==void 0);const h=ReadableStreamDefaultControllerGetDesiredSize(this._readableController);TransformStreamSetBackpressure(this,0>=h);const i=this,j=InvokeOrNoop(a,'start',[i._transformStreamController]);d(j),e.catch((a)=>{!1===i._errored&&(i._errored=!0,i._storedError=a)})}get readable(){if(!1===IsTransformStream(this))throw streamBrandCheckException('readable');return this._readable}get writable(){if(!1===IsTransformStream(this))throw streamBrandCheckException('writable');return this._writable}}function defaultControllerBrandCheckException(a){return new TypeError(`TransformStreamDefaultController.prototype.${a} can only be used on a TransformStreamDefaultController`)}function ReadableStreamDefaultControllerEnqueue(a,b){a.enqueue(b)}function ReadableStreamDefaultControllerGetDesiredSize(a){return a.desiredSize}function ReadableStreamDefaultControllerClose(a){a.close()}function ReadableStreamDefaultControllerError(a,b){a.error(b)}function WritableStreamDefaultControllerError(a,b){a.error(b)}function streamBrandCheckException(a){return new TypeError(`TransformStream.prototype.${a} can only be used on a TransformStream`)}function IsPropertyKey(a){return'string'==typeof a||'symbol'==typeof a}function typeIsObject(a){return'object'==typeof a&&null!==a||'function'==typeof a}function Call(a,b,c){if('function'!=typeof a)throw new TypeError('Argument is not a function');return Function.prototype.apply.call(a,b,c)}function InvokeOrNoop(a,b,c){assert(a!==void 0),assert(IsPropertyKey(b)),assert(Array.isArray(c));const d=a[b];return void 0===d?void 0:Call(d,a,c)}function PromiseInvokeOrNoop(a,b,c){assert(a!==void 0),assert(IsPropertyKey(b)),assert(Array.isArray(c));try{return Promise.resolve(InvokeOrNoop(a,b,c))}catch(a){return Promise.reject(a)}}function PromiseInvokeOrPerformFallback(a,b,c,d,e){assert(a!==void 0),assert(IsPropertyKey(b)),assert(Array.isArray(c)),assert(Array.isArray(e));let f;try{f=a[b]}catch(a){return Promise.reject(a)}if(f===void 0)return d(...e);try{return Promise.resolve(Call(f,a,c))}catch(a){return Promise.reject(a)}}function assert(a,b){class c extends Error{constructor(a){super(a)}}if(!a)throw console.log(`TransformStream internal logic error: assertion failed: s`),new c(b)}