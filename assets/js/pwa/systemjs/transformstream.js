System.register([],function(){'use strict';function a(a){if(!0===a._errored)throw new TypeError('TransformStream is already errored');if(!0===a._readableClosed)throw new TypeError('Readable side is already closed');d(a)}function b(a,b){if(!0===a._errored)throw new TypeError('TransformStream is already errored');if(!0===a._readableClosed)throw new TypeError('Readable side is already closed');const c=a._readableController;try{n(c,b)}catch(b){throw a._readableClosed=!0,f(a,b),a._storedError}const d=o(c);!0==0>=d&&!1===a._backpressure&&h(a,!0)}function c(a,b){if(!0===a._errored)throw new TypeError('TransformStream is already errored');g(a,b)}function d(a){z(!1===a._errored),z(!1===a._readableClosed);try{p(a._readableController)}catch(a){z(!1)}a._readableClosed=!0}function f(a,b){!1===a._errored&&g(a,b)}function g(a,b){z(!1===a._errored),a._errored=!0,a._storedError=b,!1===a._writableDone&&r(a._writableController,b),!1===a._readableClosed&&q(a._readableController,b)}function e(a){return(z(void 0!==a._backpressureChangePromise,'_backpressureChangePromise should have been initialized'),!1===a._backpressure)?Promise.resolve():(z(!0===a._backpressure,'_backpressure should have been initialized'),a._backpressureChangePromise)}function h(a,b){z(a._backpressure!==b,'TransformStreamSetBackpressure() should be called only when backpressure is changed'),a._backpressureChangePromise!==void 0&&a._backpressureChangePromise_resolve(b),a._backpressureChangePromise=new Promise((b)=>{a._backpressureChangePromise_resolve=b}),a._backpressureChangePromise.then((a)=>{z(a!==b,'_backpressureChangePromise should be fulfilled only when backpressure is changed')}),a._backpressure=b}function i(a,c){const d=c._controlledTransformStream;return b(d,a),Promise.resolve()}function j(a,b){z(!1===a._errored),z(!1===a._transforming),z(!1===a._backpressure),a._transforming=!0;const c=a._transformer,d=a._transformStreamController,g=y(c,'transform',[b,d],i,[b,d]);return g.then(()=>{return a._transforming=!1,e(a)},(b)=>{return f(a,b),Promise.reject(b)})}function k(a){return!!u(a)&&!!Object.prototype.hasOwnProperty.call(a,'_controlledTransformStream')}function l(a){return!!u(a)&&!!Object.prototype.hasOwnProperty.call(a,'_transformStreamController')}function m(a){return new TypeError(`TransformStreamDefaultController.prototype.${a} can only be used on a TransformStreamDefaultController`)}function n(a,b){a.enqueue(b)}function o(a){return a.desiredSize}function p(a){a.close()}function q(a,b){a.error(b)}function r(a,b){a.error(b)}function s(a){return new TypeError(`TransformStream.prototype.${a} can only be used on a TransformStream`)}function t(a){return'string'==typeof a||'symbol'==typeof a}function u(a){return'object'==typeof a&&null!==a||'function'==typeof a}function v(a,b,c){if('function'!=typeof a)throw new TypeError('Argument is not a function');return Function.prototype.apply.call(a,b,c)}function w(a,b,c){z(a!==void 0),z(t(b)),z(Array.isArray(c));const d=a[b];return void 0===d?void 0:v(d,a,c)}function x(a,b,c){z(a!==void 0),z(t(b)),z(Array.isArray(c));try{return Promise.resolve(w(a,b,c))}catch(a){return Promise.reject(a)}}function y(a,b,c,d,e){z(a!==void 0),z(t(b)),z(Array.isArray(c)),z(Array.isArray(e));let f;try{f=a[b]}catch(a){return Promise.reject(a)}if(f===void 0)return d(...e);try{return Promise.resolve(v(f,a,c))}catch(a){return Promise.reject(a)}}function z(a,b){class c extends Error{constructor(a){super(a)}}if(!a)throw console.log(`TransformStream internal logic error: assertion failed: s`),new c(b)}return{setters:[],execute:function(){class i{constructor(a,b){this._transformStream=a,this._startPromise=b}start(a){const b=this._transformStream;return b._writableController=a,this._startPromise.then(()=>e(b))}write(a){const b=this._transformStream;return j(b,a)}abort(){const a=this._transformStream;a._writableDone=!0,g(a,new TypeError('Writable side aborted'))}close(){const a=this._transformStream;z(!1===a._transforming),a._writableDone=!0;const b=x(a._transformer,'flush',[a._transformStreamController]);return b.then(()=>{return!0===a._errored?Promise.reject(a._storedError):(!1===a._readableClosed&&d(a),Promise.resolve())}).catch((b)=>{return f(a,b),Promise.reject(a._storedError)})}}class n{constructor(a,b){this._transformStream=a,this._startPromise=b}start(a){const b=this._transformStream;return b._readableController=a,this._startPromise.then(()=>{return(z(void 0!==b._backpressureChangePromise,'_backpressureChangePromise should have been initialized'),!0===b._backpressure)?Promise.resolve():(z(!1===b._backpressure,'_backpressure should have been initialized'),b._backpressureChangePromise)})}pull(){const a=this._transformStream;return z(!0===a._backpressure,'pull() should be never called while _backpressure is false'),z(void 0!==a._backpressureChangePromise,'_backpressureChangePromise should have been initialized'),h(a,!1),a._backpressureChangePromise}cancel(){const a=this._transformStream;a._readableClosed=!0,g(a,new TypeError('Readable side canceled'))}}class p{constructor(a){if(!1===l(a))throw new TypeError('TransformStreamDefaultController can only be constructed with a TransformStream instance');if(void 0!==a._transformStreamController)throw new TypeError('TransformStreamDefaultController instances can only be created by the TransformStream constructor');this._controlledTransformStream=a}get desiredSize(){if(!1===k(this))throw m('desiredSize');const a=this._controlledTransformStream,b=a._readableController;return o(b)}enqueue(a){if(!1===k(this))throw m('enqueue');b(this._controlledTransformStream,a)}close(){if(!1===k(this))throw m('close');a(this._controlledTransformStream)}error(a){if(!1===k(this))throw m('error');c(this._controlledTransformStream,a)}}class q{constructor(a={}){this._transformer=a;const{readableStrategy:b,writableStrategy:c}=a;this._transforming=!1,this._errored=!1,this._storedError=void 0,this._writableController=void 0,this._readableController=void 0,this._transformStreamController=void 0,this._writableDone=!1,this._readableClosed=!1,this._backpressure=void 0,this._backpressureChangePromise=void 0,this._backpressureChangePromise_resolve=void 0,this._transformStreamController=new p(this);let d;const e=new Promise((a)=>{d=a}),f=new n(this,e);this._readable=new ReadableStream(f,b);const g=new i(this,e);this._writable=new WritableStream(g,c),z(this._writableController!==void 0),z(this._readableController!==void 0);const j=o(this._readableController);h(this,0>=j);const k=this,l=w(a,'start',[k._transformStreamController]);d(l),e.catch((a)=>{!1===k._errored&&(k._errored=!0,k._storedError=a)})}get readable(){if(!1===l(this))throw s('readable');return this._readable}get writable(){if(!1===l(this))throw s('writable');return this._writable}}}}});